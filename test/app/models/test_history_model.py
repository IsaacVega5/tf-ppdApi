import pytest
from datetime import datetime, timezone
import uuid
from sqlmodel import Session, SQLModel, create_engine
from app.models.History import History, HistoryBase
import time

# Fixtures para datos de prueba
@pytest.fixture
def valid_history_data():
    return {
        "id_report": "report_123",
        "id_variable": "variable_456",
        "value": "sample_value",
    }

@pytest.fixture
def minimal_history_data():
    return {
        "value": "minimal_value"
    }

# Configuración de base de datos en memoria
DATABASE_URL = "sqlite:///:memory:"
engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})

@pytest.fixture(name="session", scope="function")
def session_fixture():
    """Fixture para sesión de base de datos con transacción aislada por test."""
    SQLModel.metadata.create_all(engine)
    
    connection = engine.connect()
    transaction = connection.begin()
    session = Session(bind=connection)

    yield session

    session.close()
    transaction.rollback()
    connection.close()

# Tests para HistoryBase
class TestHistoryBase:
    def test_create_with_valid_data(self, valid_history_data):
        """Prueba creación con datos válidos"""
        history = HistoryBase(**valid_history_data)
        assert history.id_report == "report_123"
        assert history.id_variable == "variable_456"
        assert history.value == "sample_value"
        assert isinstance(history.created_at, int)
        assert isinstance(history.updated_at, int)

    def test_create_with_minimal_data(self, minimal_history_data):
        """Prueba creación con datos mínimos"""
        history = HistoryBase(**minimal_history_data)
        assert history.value == "minimal_value"
        assert history.id_report is None
        assert history.id_variable is None
        assert isinstance(history.created_at, int)
        assert isinstance(history.updated_at, int)

    def test_timestamps_auto_generated(self):
        """Test que los timestamps se generan automáticamente"""
        before = int(datetime.now(timezone.utc).timestamp())
        history = HistoryBase(value="test")
        after = int(datetime.now(timezone.utc).timestamp())
        
        assert before <= history.created_at <= after
        assert before <= history.updated_at <= after

# Tests para History
class TestHistory:
    def test_inherits_from_historybase(self):
        """Verifica la herencia correcta"""
        assert issubclass(History, HistoryBase)
        assert issubclass(History, SQLModel)

    def test_table_configuration(self):
        """Verifica configuración de tabla"""
        assert History.__tablename__ == "history"
        assert hasattr(History, "__table__")
        assert History.__table__.primary_key.columns.keys() == ["id_history"]

    def test_primary_key_autogenerated(self):
        """Test que id_history es generado automáticamente"""
        history = History(value="test")
        assert history.id_history is not None
        assert uuid.UUID(history.id_history, version=4)  # Verifica que es UUID válido

    def test_relationships_defined(self):
        """Test que las relaciones están definidas"""
        assert hasattr(History, "report")
        assert hasattr(History, "variable")
        
        relationships = History.__sqlmodel_relationships__
        assert "report" in relationships
        assert "variable" in relationships
        assert relationships["report"].back_populates == "history_list"
        assert relationships["variable"].back_populates == "history_list"

# Tests de integración con base de datos
class TestHistoryDB:
    def test_save_to_database(self, session: Session, valid_history_data):
        """Test que se puede guardar en base de datos"""
        history = History(**valid_history_data)
        session.add(history)
        session.commit()
        session.refresh(history)
        
        assert history.id_history is not None
        assert history.value == "sample_value"
        assert isinstance(history.created_at, int)
        assert isinstance(history.updated_at, int)

    def test_retrieve_from_database(self, session: Session, valid_history_data):
        """Test que se puede recuperar de la base de datos"""
        history = History(**valid_history_data)
        session.add(history)
        session.commit()
        
        retrieved = session.get(History, history.id_history)
        assert retrieved is not None
        assert retrieved.value == history.value
        assert retrieved.id_history == history.id_history

    def test_update_history(self, session: Session, valid_history_data):
        """Test que se puede actualizar un History"""
        history = History(**valid_history_data)
        session.add(history)
        session.commit()
        session.refresh(history)
        
        original_updated_at = history.updated_at
        
        # Pequeña pausa para asegurar diferentes timestamps
        time.sleep(1)
        
        new_value = "updated_value"
        history.value = new_value
        history.updated_at = int(datetime.now(timezone.utc).timestamp())
        session.commit()
        session.refresh(history)
        
        updated = session.get(History, history.id_history)
        assert updated.value == new_value
        assert updated.updated_at > original_updated_at

    def test_delete_history(self, session: Session, valid_history_data):
        """Test que se puede eliminar un History"""
        history = History(**valid_history_data)
        session.add(history)
        session.commit()
        
        session.delete(history)
        session.commit()
        
        deleted = session.get(History, history.id_history)
        assert deleted is None